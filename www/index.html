<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TDS530 TCP Logger</title>
    <script src="tailwind.min.js"></script>
    <script src="chart.min.js"></script>
    <style>
        .val-shadow { text-shadow: 0 0 4px rgba(255,255,255,0.8), 0 0 4px rgba(255,255,255,0.8), 0 0 4px rgba(255,255,255,0.8); }
    </style>
</head>
<body class="bg-gray-100 min-h-screen px-6 py-4">
    <div class="max-w-[1800px] mx-auto">
        <!-- Header Bar: Title + Timestamp + Status + Controls in one row -->
        <div class="bg-white rounded-lg shadow-md px-6 py-3 mb-3 flex items-center gap-6 flex-wrap">
            <h1 class="text-2xl font-bold text-gray-800 whitespace-nowrap">TDS530 Data Monitor</h1>
            <div class="flex items-center gap-2">
                <span class="text-sm text-gray-500">Last Update:</span>
                <span id="timestamp" class="text-lg font-semibold text-gray-800">--</span>
            </div>
            <span id="status" class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800">
                <span class="w-2 h-2 mr-2 rounded-full bg-gray-400"></span>
                Connecting...
            </span>
            <div class="flex items-center gap-3 ml-auto">
                <button id="startSaveBtn" class="px-4 py-2 rounded-md bg-blue-600 text-white hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed">保存開始</button>
                <button id="stopSaveBtn" class="px-4 py-2 rounded-md bg-gray-600 text-white hover:bg-gray-700 disabled:opacity-50 disabled:cursor-not-allowed" disabled>保存終了</button>
                <span id="saveStatus" class="text-sm text-gray-600">未保存</span>
            </div>
        </div>

        <!-- Data Cards Grid -->
        <div id="dataContainer" class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-10 gap-3">
            <!-- Cards will be inserted here dynamically -->
        </div>
    </div>

    <script>
        const dataContainer = document.getElementById('dataContainer');
        const timestampEl = document.getElementById('timestamp');
        const statusEl = document.getElementById('status');
        const startSaveBtn = document.getElementById('startSaveBtn');
        const stopSaveBtn = document.getElementById('stopSaveBtn');
        const saveStatusEl = document.getElementById('saveStatus');

        // Fetch/sync state
        let lastTime = null;
        let isFetching = false;
        let isSaving = false;
        let wasConnected = false;

        // Chart state
        const FIFO_SIZE = 512;
        const CHART_BLUE   = 'rgba(37, 99, 235, 0.25)';
        const CHART_ORANGE = 'rgba(234, 88, 12, 0.25)';
        let channelCharts = {};
        let channelCount  = 0;
        let tickCounter   = 0;

        function chartColorForValue(value) {
            return value >= 0 ? CHART_BLUE : CHART_ORANGE;
        }

        function textColorForValue(value) {
            return value < 0 ? '#ea580c' : '#2563eb';
        }

        function updateStatus(isConnected, message = '') {
            if (!isConnected && wasConnected) {
                resetCharts();
            }
            wasConnected = isConnected;
            if (isConnected) {
                statusEl.innerHTML = `
                    <span class="w-2 h-2 mr-2 rounded-full bg-green-500 animate-pulse"></span>
                    Connected
                `;
                statusEl.className = 'inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-green-100 text-green-800';
            } else {
                statusEl.innerHTML = `
                    <span class="w-2 h-2 mr-2 rounded-full bg-red-500"></span>
                    ${message || 'Disconnected'}
                `;
                statusEl.className = 'inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-red-100 text-red-800';
            }
        }

        function formatChannelLabel(index) {
            return `CH${String(index).padStart(3, '0')}`;
        }

        function formatValue(value) {
            if (value === null || value === undefined || value === 'None') {
                return 'None';
            }
            const sign = value >= 0 ? '+' : '-';
            const absVal = Math.abs(value);
            const intStr = Math.floor(absVal).toString();
            const maxNumLen = 7; // 8 total - 1 for sign
            if (intStr.length >= maxNumLen) {
                return sign + intStr.substring(0, maxNumLen);
            }
            const fracDigits = maxNumLen - intStr.length - 1; // -1 for '.'
            if (fracDigits <= 0) {
                return sign + intStr;
            }
            let formatted = absVal.toFixed(fracDigits);
            if (formatted.length > maxNumLen) {
                formatted = formatted.substring(0, maxNumLen);
                if (formatted.endsWith('.')) {
                    formatted = formatted.slice(0, -1);
                }
            }
            return sign + formatted;
        }

        function createCards(count) {
            // Destroy existing charts to free memory
            Object.values(channelCharts).forEach(c => c.destroy());
            channelCharts = {};
            dataContainer.innerHTML = '';
            channelCount = count;
            tickCounter  = 0;

            for (let i = 0; i < count; i++) {
                const card = document.createElement('div');
                card.className = 'bg-white rounded-lg shadow-md hover:shadow-lg transition-shadow duration-200 relative overflow-hidden h-[148px]';

                // Chart background container (fills card, behind text)
                const chartWrap = document.createElement('div');
                chartWrap.style.cssText = 'position:absolute;inset:0;pointer-events:none;';
                const canvas = document.createElement('canvas');
                chartWrap.appendChild(canvas);
                card.appendChild(chartWrap);

                // Text overlay (on top of chart)
                const content = document.createElement('div');
                content.className = 'relative z-10 px-2 py-1 h-full flex flex-col justify-between pointer-events-none select-none';
                content.innerHTML = `
                    <div class="text-xs font-semibold text-gray-500">${formatChannelLabel(i)}</div>
                    <div id="val-${i}" class="val-shadow text-2xl font-bold font-mono leading-none text-right" style="color:rgba(0,0,0,0.05)">None</div>
                `;
                card.appendChild(content);

                dataContainer.appendChild(card);

                // Create Chart.js instance
                try { channelCharts[i] = new Chart(canvas.getContext('2d'), {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [{
                            data: [],
                            borderColor: CHART_BLUE,
                            borderWidth: 2,
                            pointRadius: 0,
                            fill: false,
                            tension: 0.2,
                            spanGaps: false
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        animation: false,
                        plugins: {
                            legend:  { display: false },
                            tooltip: { enabled: false }
                        },
                        scales: {
                            x: { display: false },
                            y: {
                                display: true,
                                ticks:  { display: false },
                                border: { display: false },
                                grid: {
                                    display: true,
                                    color: 'rgba(0,0,0,0.03)'
                                }
                            }
                        }
                    }
                }); } catch (e) { console.error(`[createCards] Chart init error for CH${i}:`, e); }
            }
        }

        function updateCards(data) {
            tickCounter++;
            for (let i = 0; i < data.length; i++) {
                const value  = data[i];
                const isNull = value === null || value === undefined || value === 'None';

                // Update value display
                const valEl = document.getElementById(`val-${i}`);
                if (valEl) {
                    valEl.style.color = isNull ? 'rgba(0,0,0,0.05)' : textColorForValue(value);
                    valEl.textContent = formatValue(value);
                }

                // Update chart buffer (skip null values)
                if (!isNull) {
                    const chart = channelCharts[i];
                    if (chart) {
                        const labels  = chart.data.labels;
                        const dataset = chart.data.datasets[0];
                        labels.push(tickCounter);
                        dataset.data.push(value);
                        if (labels.length > FIFO_SIZE) {
                            labels.shift();
                            dataset.data.shift();
                        }
                        dataset.borderColor = chartColorForValue(value);
                        chart.update('none');
                    }
                }
            }
        }

        function resetCharts() {
            tickCounter = 0;
            for (let i = 0; i < channelCount; i++) {
                const chart = channelCharts[i];
                if (chart) {
                    chart.data.labels = [];
                    chart.data.datasets[0].data        = [];
                    chart.data.datasets[0].borderColor = CHART_BLUE;
                    chart.update('none');
                }
                const valEl = document.getElementById(`val-${i}`);
                if (valEl) {
                    valEl.style.color = 'rgba(0,0,0,0.05)';
                    valEl.textContent = 'None';
                }
            }
        }

        function renderData(data, time) {
            // Update timestamp
            timestampEl.textContent = time;

            // (Re)create cards only when channel count changes
            if (data.length !== channelCount) {
                createCards(data.length);
            }

            updateCards(data);
        }

        async function fetchData() {
            if (isFetching) return;
            isFetching = true;
            try {
                // Use pywebview's JavaScript API to call Python method
                const jsonData = await pywebview.api.get_latest_data();
                
                if (jsonData.error) {
                    updateStatus(false, jsonData.error);
                    return;
                }
                
                if (jsonData.data && jsonData.time) {
                    // Only update UI when time changes
                    if (jsonData.time !== lastTime) {
                        lastTime = jsonData.time;
                        renderData(jsonData.data, jsonData.time);
                    }
                    updateStatus(true);
                    
                    // Update save status if saving
                    if (isSaving) {
                        saveStatusEl.textContent = `保存中: ${jsonData.data.length}ch / 最新 ${jsonData.time}`;
                    }
                } else {
                    updateStatus(false, 'Invalid data format');
                }
            } catch (error) {
                console.error('[fetchData] error:', error);
                updateStatus(false, 'Error: ' + error.message);
            } finally {
                isFetching = false;
            }
        }

        async function startSaving() {
            if (isSaving) return;
            
            startSaveBtn.disabled = true;
            saveStatusEl.textContent = '保存先を選択…';
            
            try {
                // Use pywebview's file dialog
                const result = await pywebview.api.select_save_file();
                
                if (result.cancelled) {
                    startSaveBtn.disabled = false;
                    saveStatusEl.textContent = '未保存';
                    return;
                }
                
                // Start saving on Python side
                const saveResult = await pywebview.api.start_saving(result.filepath);
                
                if (saveResult.error) {
                    startSaveBtn.disabled = false;
                    saveStatusEl.textContent = 'エラー: ' + saveResult.error;
                    return;
                }
                
                isSaving = true;
                startSaveBtn.disabled = true;
                stopSaveBtn.disabled = false;
                saveStatusEl.textContent = '保存中（TSV）';
                
            } catch (e) {
                console.error('[startSaving] error:', e);
                startSaveBtn.disabled = false;
                saveStatusEl.textContent = '未保存';
            }
        }

        async function stopSaving() {
            if (!isSaving) return;
            
            try {
                await pywebview.api.stop_saving();
                isSaving = false;
                startSaveBtn.disabled = false;
                stopSaveBtn.disabled = true;
                saveStatusEl.textContent = '保存完了（TSV）';
            } catch (e) {
                console.error('[stopSaving] error:', e);
                saveStatusEl.textContent = '保存エラー';
            }
        }

        // Wait for pywebview API to be ready
        window.addEventListener('pywebviewready', function() {
            // Verify API is available
            if (typeof pywebview === 'undefined' || typeof pywebview.api === 'undefined') {
                console.error('pywebview API is not available');
                updateStatus(false, 'API not available');
                return;
            }
            
            console.log('pywebview API is ready');
            
            startSaveBtn.addEventListener('click', () => { startSaving(); });
            stopSaveBtn.addEventListener('click', () => { stopSaving(); });

            // Initial fetch
            fetchData();
            // Poll every 500ms
            setInterval(fetchData, 500);
        });
    </script>
</body>
</html>
