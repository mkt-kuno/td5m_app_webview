<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TDS530 TCP Logger</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-100 min-h-screen p-6">
    <div class="max-w-7xl mx-auto">
        <h1 class="text-3xl font-bold text-gray-800 mb-6">TDS530 Data Monitor</h1>
        
        <!-- Timestamp Display -->
        <div class="bg-white rounded-lg shadow-md p-4 mb-6">
            <div class="text-sm text-gray-600">Last Update:</div>
            <div id="timestamp" class="text-xl font-semibold text-gray-800">--</div>
        </div>

        <!-- Status + Controls -->
        <div class="mb-6 flex flex-col gap-3 md:flex-row md:items-center md:justify-between">
            <span id="status" class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800">
                <span class="w-2 h-2 mr-2 rounded-full bg-gray-400"></span>
                Connecting...
            </span>
            <div class="flex items-center gap-3">
                <button id="startSaveBtn" class="px-4 py-2 rounded-md bg-blue-600 text-white hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed">保存開始</button>
                <button id="stopSaveBtn" class="px-4 py-2 rounded-md bg-gray-600 text-white hover:bg-gray-700 disabled:opacity-50 disabled:cursor-not-allowed" disabled>保存終了</button>
                <span id="saveStatus" class="text-sm text-gray-600">未保存</span>
            </div>
        </div>

        <!-- Data Cards Grid -->
        <div id="dataContainer" class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-5 xl:grid-cols-10 gap-4">
            <!-- Cards will be inserted here dynamically -->
        </div>
    </div>

    <script>
        const dataContainer = document.getElementById('dataContainer');
        const timestampEl = document.getElementById('timestamp');
        const statusEl = document.getElementById('status');
            const startSaveBtn = document.getElementById('startSaveBtn');
            const stopSaveBtn = document.getElementById('stopSaveBtn');
            const saveStatusEl = document.getElementById('saveStatus');

        // Fetch/sync state
        let lastTime = null;
        let lastData = null;
        let isFetching = false;

        // Saving state
        let isSaving = false; // true only after destination confirmed
        let savingPending = false; // between click and destination confirmation
        let fsWritable = null; // FileSystemWritableFileStream | null
        let bufferLines = [];
        let headerWritten = false;
        let headerChannelCount = 0;
        let headerWrittenToThisFile = false; // 新規ファイルに対してヘッダーを書いたか

        // Utilities
        const sleep = (ms) => new Promise((r) => setTimeout(r, ms));
        async function forceFetchLatest() {
            let tries = 0;
            while (isFetching && tries < 100) { // wait up to ~1s
                await sleep(10);
                tries += 1;
            }
            console.debug('[forceFetchLatest] start (tries=%d)', tries);
            await fetchData();
            console.debug('[forceFetchLatest] done');
        }

        function updateStatus(isConnected, message = '') {
            if (isConnected) {
                statusEl.innerHTML = `
                    <span class="w-2 h-2 mr-2 rounded-full bg-green-500 animate-pulse"></span>
                    Connected
                `;
                statusEl.className = 'inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-green-100 text-green-800';
            } else {
                statusEl.innerHTML = `
                    <span class="w-2 h-2 mr-2 rounded-full bg-red-500"></span>
                    ${message || 'Disconnected'}
                `;
                statusEl.className = 'inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-red-100 text-red-800';
            }
        }

        function formatChannelLabel(index) {
            return `CH${String(index).padStart(3, '0')}`;
        }

        function formatValue(value) {
            if (value === null || value === undefined) {
                return 'N/A';
            }
            return value.toFixed(2);
        }

        function renderData(data, time) {
            // Update timestamp
            timestampEl.textContent = time;

            // Clear existing cards
            dataContainer.innerHTML = '';

            // Create cards for each channel
            data.forEach((value, index) => {
                const card = document.createElement('div');
                card.className = 'bg-white rounded-lg shadow-md p-4 hover:shadow-lg transition-shadow duration-200';
                
                const isNull = value === null || value === undefined;
                const valueClass = isNull ? 'text-gray-400' : 'text-blue-600';
                
                card.innerHTML = `
                    <div class="text-xs font-semibold text-gray-600 mb-2">${formatChannelLabel(index)}</div>
                    <div class="text-2xl font-bold ${valueClass}">${formatValue(value)}</div>
                `;
                
                dataContainer.appendChild(card);
            });
        }

        async function fetchData() {
                if (isFetching) return;
                console.debug('[fetchData] start');
                isFetching = true;
            try {
                const response = await fetch('/v1/');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const jsonData = await response.json();
                if (jsonData && Array.isArray(jsonData.data)) {
                    lastData = jsonData.data;
                }
                console.debug('[fetchData] ok time=%s len=%s', jsonData?.time, jsonData?.data?.length);
                
                    if (jsonData.data && jsonData.time) {
                        // Only update UI and saving when time changes
                        if (jsonData.time !== lastTime) {
                            console.debug('[fetchData] time changed %s -> %s', lastTime, jsonData.time);
                            lastTime = jsonData.time;
                            renderData(jsonData.data, jsonData.time);
                            if (isSaving) {
                                console.debug('[fetchData] appendCsv for %s', jsonData.time);
                                await appendCsv(jsonData.time, jsonData.data);
                            }
                        }
                        updateStatus(true);
                } else {
                    throw new Error('Invalid data format');
                }
            } catch (error) {
                console.error('[fetchData] error:', error);
                updateStatus(false, 'Error: ' + error.message);
                } finally {
                    isFetching = false;
                    console.debug('[fetchData] end');
            }
        }

            // TSV helpers
            function tsvEscape(value) {
                // For TSV, replace tabs and newlines with spaces
                const s = String(value);
                return s.replace(/[\t\n\r]/g, ' ');
            }

            function makeHeader(count) {
                const labels = Array.from({ length: count }, (_, i) => `CH${String(i).padStart(3, '0')}`);
                return ['time', ...labels].join('\t') + '\n';
            }

            async function writeText(text) {
                try {
                    if (fsWritable) {
                        const bytes = new TextEncoder().encode(text);
                        await fsWritable.write(bytes);
                        console.debug('[writeText] wrote to file bytes=%d', bytes.length);
                    } else {
                        bufferLines.push(text);
                        console.debug('[writeText] buffered length now=%d', bufferLines.length);
                    }
                } catch (e) {
                    console.error('[writeText] error:', e);
                    throw e;
                }
            }

            async function appendCsv(time, data) {
                if (!isSaving) {
                    console.debug('[appendCsv] skip: not saving');
                    return;
                }
                console.debug('[appendCsv] time=%s headerWritten=%s headerWrittenToThisFile=%s', time, headerWritten, headerWrittenToThisFile);
                // 新しいファイルに対しては、必ず先にヘッダーを出力する
                if (!headerWrittenToThisFile) {
                    headerChannelCount = data.length;
                    console.debug('[appendCsv] writing header to file with %d channels', headerChannelCount);
                    await writeText(makeHeader(headerChannelCount));
                    headerWritten = true; // 論理的にもヘッダー済みとする
                    headerWrittenToThisFile = true; // このファイルにも出力済み
                    console.debug('[appendCsv] header written to file');
                }
                const cols = [tsvEscape(time), ...data.map(v => (v === null || v === undefined) ? '' : tsvEscape(String(v)))];
                await writeText(cols.join('\t') + '\n');
                console.debug('[appendCsv] row written for %s', time);
                saveStatusEl.textContent = `保存中: ${headerChannelCount}ch / 最新 ${time}`;
            }

            async function startSaving() {
                console.log('[startSaving] click');
                if (isSaving || savingPending) return;
                // Arm, but do not start writing until destination is ready
                savingPending = true;
                headerWritten = false;
                headerChannelCount = 0;
                bufferLines = [];
                fsWritable = null;
                headerWrittenToThisFile = false;

                startSaveBtn.disabled = true;
                stopSaveBtn.disabled = true;
                saveStatusEl.textContent = '保存先を選択…';

                try {
                    if (window.showSaveFilePicker) {
                        const handle = await window.showSaveFilePicker({
                            suggestedName: 'tds530_log.tsv',
                            types: [{ description: 'TSV', accept: { 'text/tab-separated-values': ['.tsv'] } }],
                            excludeAcceptAllOption: false
                        });
                        fsWritable = await handle.createWritable({ keepExistingData: false });
                        console.log('[startSaving] writable acquired');
                        // Now saving is active
                        isSaving = true;
                        stopSaveBtn.disabled = false;
                        saveStatusEl.textContent = '保存中（TSV）';
                    } else {
                        // Fallback: buffer in memory and download on stop
                        console.log('[startSaving] fallback buffer mode');
                        // Activate saving in buffer mode
                        isSaving = true;
                        stopSaveBtn.disabled = false;
                        saveStatusEl.textContent = '保存中（TSV, ブラウザ保存）';
                    }

                    // Force one fetch to ensure we have latest layout
                    await forceFetchLatest();
                    console.debug('[startSaving] lastData len=%s', lastData?.length);

                    // Write header immediately if we already know channel count
                    if (Array.isArray(lastData) && !headerWrittenToThisFile) {
                        headerChannelCount = lastData.length;
                        console.debug('[startSaving] writing header immediately with %d channels', headerChannelCount);
                        await writeText(makeHeader(headerChannelCount));
                        headerWritten = true;
                        headerWrittenToThisFile = true;
                        console.debug('[startSaving] header written (start)');
                        // Also write the current row immediately if we know time
                        if (lastTime) {
                            console.debug('[startSaving] writing immediate first row for %s', lastTime);
                            await appendCsv(lastTime, lastData);
                        }
                    }
                } catch (e) {
                    // User canceled
                    isSaving = false;
                    savingPending = false;
                    startSaveBtn.disabled = false;
                    stopSaveBtn.disabled = true;
                    saveStatusEl.textContent = '未保存';
                    console.warn('[startSaving] canceled or error:', e);
                }
            }
                // Successfully activated
                savingPending = false;

            async function stopSaving() {
                console.log('[stopSaving] click');
                if (!isSaving && !savingPending) return;
                isSaving = false;
                savingPending = false;
                startSaveBtn.disabled = false;
                stopSaveBtn.disabled = true;

                try {
                    if (fsWritable) {
                        await fsWritable.close();
                        fsWritable = null;
                        saveStatusEl.textContent = '保存完了（TSV）';
                        console.log('[stopSaving] writable closed');
                    } else {
                        const blob = new Blob(bufferLines, { type: 'text/tab-separated-values' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = 'tds530_log.tsv';
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                        saveStatusEl.textContent = '保存完了（TSV, ダウンロード）';
                        console.log('[stopSaving] download triggered');
                    }
                } catch (e) {
                    console.error('[stopSaving] 保存エラー:', e);
                    saveStatusEl.textContent = '保存エラー';
                }
            }

            startSaveBtn.addEventListener('click', () => { startSaving(); });
            stopSaveBtn.addEventListener('click', () => { stopSaving(); });

            // Initial fetch
            fetchData();
            // Poll every 500ms
            setInterval(fetchData, 500);
    </script>
</body>
</html>
